# Сказка о хорошем коде

## Введение

Люди до сих пор спорят, что такое "хороший" код, будто это не бесконечный калейдоскоп вкусов и мнений, где каждая новая
мода кажется революцией до тех пор, пока не уступит место очередной "инновационной" методике.

Хороший код — это не набор часто упоминаемых терминов вроде «поддерживаемый», «расширяемый» и «интуитивно понятный». Это
просто код, который выполняет поставленные задачи: аккуратно подсовывает моки в тесты, шустро и без утайки решает
проблемы, заложенные бизнес-требованиями, и умудряется не вызывать хаоса в техподдержке.

Каковы же критерии? Всё меняется, как только появляется новое требование, новый фреймворк или свежий баг-репорт от
менеджмента. Читаемость? На минутку забываем, что ее оценка — не более чем субъективное мнение, подобное вкусу тех, кто
до последнего спорит о том, что лучше: табуляция или пробелы. Простота? Пока ваш код не зовёт в подвал видеокарты — дело
считается сделанным. Поддерживаемость? Если через неделю программист второй смены сможет хотя бы догадываться, зачем и
как работает ваш код, вы уже на коне.

Неудивительно, что в этой бесконечной спорной аргументации о стандартах качества можно утонуть. Большинство же не
замечают, что основная задача кода — отвечать требованиям реального мира, а не радовать души тех, кто проводит
бесконечные марафоны по линтингу и код-ревью. Если ваша программа работает и заказчик ею доволен — поздравляю, вы уже
победили в Олимпийских играх гениальности.

Так что, уважаемые претенденты на звание философов кода, может, пора перестать спорить о пустяках? Давайте лучше
научимся понимать: хороший код — это не эстетичное собрание правил, а, прежде всего, рабочий инструмент, творящий
чудеса, несмотря на все странности мира и капризы бизнеса. Ведь в конечном счёте от того, насколько быстро и качественно
отрабатываются задачи, зависит не чудо и не искусство, а просто нормальная работа.

## Хороший код

### Примеры описания хорошего кода

Дискуссии о том, что такое хороший код, ведутся уже не одно десятилетие. Разные разработчики предлагали свои
определения, и ниже приведены наиболее известные подходы:

**1. Чистый код (Clean Code) — Роберт Мартин**

В своей книге *"Clean Code: A Handbook of Agile Software Craftsmanship"* [^1] Мартин подчёркивает, что хороший код
должен быть понятным, простым и легко поддерживаемым. Он акцентирует внимание на принципах читаемости, простоты и
избежания дублирования.

**2. Принципы SOLID — Роберт Мартин**

Пять принципов SOLID [^2] (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency
Inversion) помогают создавать гибкий и поддерживаемый код, способный легко адаптироваться к изменениям.

**3. Код, который решает задачу — Кент Бек**

Кент Бек в контексте тестирования и разработки ПО акцентирует внимание на том, что хороший код должен эффективно решать
поставленные задачи, проходить проверку тестами и выдерживать удары реальности.

**4. Код, который легко читать и поддерживать — Мартин Фаулер**

В книге *"Refactoring: Improving the Design of Existing Code"* [^3] Фаулер подчёркивает важность регулярного
рефакторинга и создания кода, который можно безболезненно модифицировать.

**5. Принцип DRY (Don't Repeat Yourself) — Мартин Фаулер**

Принцип DRY [^4] призывает избегать дублирования кода, тем самым снижая вероятность ошибок и облегчая его поддержку.

**6. Принцип KISS (Keep It Simple, Stupid) — Разные авторы**

Принцип KISS [^5] гласит: системы должны быть максимально простыми, а дополнительная сложность вводится лишь при острой
необходимости.

### Общие характеристики хорошего кода

Проанализировав различные утверждения о хорошем коде, можно выделить следующие общие характеристики:

1. **Читаемость**
    - **Ясность:** Код должен быть понятным и "говорящим".
    - **Согласованность:** Использование единых стилей и соглашений по именованию.
    - **Комментирование:** Наличие комментариев для пояснения самых запутанных моментов.
    - **Структурированность:** Логическая организация кода (например, использование функций и классов).

2. **Простота**
    - **Минимализм:** Избегание ненужной сложности и лишних функций.
    - **KISS:** Поддержание простоты в решениях и архитектуре.
    - **DRY:** Исключение дублированного кода, ведь повторение — мать ошибок.

3. **Поддерживаемость**
    - **Модульность:** Код делится на независимые, легко заменяемые модули.
    - **Тестируемость:** Возможность легко писать тесты (например, юнит-тесты).
    - **Рефакторинг:** Возможность улучшения структуры кода без изменения его функциональности.

4. **Эффективность**
    - **Производительность:** Оптимизация кода для быстрого выполнения.
    - **Ресурсоёмкость:** Эффективное использование памяти и других ресурсов, без излишеств.

5. **Безопасность**
    - **Обработка ошибок:** Корректная обработка исключений и ошибок, чтобы баги не оборачивались катастрофами.
    - **Защита данных:** Предотвращение утечек и несанкционированного доступа к информации.

6. **Документация**
    - **Техническая документация:** Детальное описание архитектуры и использования кода.
    - **Автоматизированная документация:** Применение инструментов для генерации документации (например, godoc).

7. **Соответствие стандартам**
    - **Кодовые стандарты:** Придерживание общепринятых рекомендаций (например, effective go [^6]).
    - **Статический анализ:** Использование линтеров для проверки качества кода, чтобы не дать багам шанс спрятаться.

### Детальное рассмотрение ключевых характеристик и почему это всё враньё

#### 1. Читаемость

Читаемость кода — понятие субъективное, и то, что один программист считает понятным, для другого может выглядеть
запутанно. Рассмотрим наши примеры:

```asm
          global    _start

          section   .text
_start:   mov       rax, 1
          mov       rdi, 1
          mov       rsi, message
          mov       rdx, 13
          syscall
          mov       rax, 60
          xor       rdi, rdi
          syscall

          section   .data
message:  db        "Hello, World", 10
```

Ассемблерный код зачастую выглядит "мелко зернистым" и требует глубокого знания архитектуры процессора и ассемблерных
инструкций. Для специалиста, привыкшего работать с высокоуровневыми языками, такой код может показаться совсем
нечитабельным, даже если структура очень простая — вызов системных вызовов, использование регистров и переходы. Однако
для программиста, который постоянно работает с низкоуровневым кодом, подобный подход может быть вполне привычным.

Теперь сравним с примером на Python:

```python
def f(n):
    return (
        1 if n < 2
        else n * f(n - 1)
        if (lambda x: x % 2 == 0)(n)
        else (lambda x: x * f(x - 1))(n - 1)
    )


def g(x):
    return (
        (lambda y: y + 1)(x)
        if x < 5
        else (lambda y: y - 1)(x)
    )


def h(a):
    return [g(i) for i in range(a)]


print(h(f(5)))
```

```python
def factorial(n):
    if n < 2:
        return 1
    return n * factorial(n - 1)


def adjust_value(x):
    if x < 5:
        return x + 1
    return x - 1


def generate_adjusted_list(a):
    return [adjust_value(i) for i in range(a)]


result = generate_adjusted_list(factorial(5))
print(result)
```

В **первом примере** одни и те же операции (например, вычисление факториала или корректировка значения) записаны
посредством
вложенных тернарных операторов и лямбда-функций. Такой стиль может понравиться тем, кто ценит лаконичность и
функциональное программирование. Однако для большинства разработчиков такой код может быть сложен для восприятия, так
как запутанная логика и вложенные вызовы затрудняют понимание намерения автора.

Код **второго примера** структурирован более ясно: функции имеют понятные имена (factorial, adjust_value,
generate_adjusted_list), а логика в них записана с использованием обычных условных операторов if/else. Для большинства
программистов такой стиль выглядит более "читабельным", так как он следует общепринятой логике, не перегруженной
вложенностью и абстракцией.

**Главная мысль**: читаемость — это не столько о следовании какому-то набору жестких правил (например, гайдлайну от
AirBnB
для JS), сколько о том, насколько знаком разработчик с данной семантикой и стилем кода. Если вы привыкли читать
функционально-компактный код с использованием лямбд и тернарников, то вы можете не испытывать проблем с первым примером.
Если же вы привыкли к традиционному императивному стилю, где функции и переменные имеют говорящие имена, то второй
пример окажется для вас гораздо понятнее.

**Опыт и привычка**. То, что для одного программиста читаемо, для другого может оказаться трудным для понимания.
Контекст и область применения. В некоторых случаях лаконичность и компактность — ключевые факторы, в других — важнее
ясность и явное разделение логики.
В итоге, разумный подход — это выбор стиля, который соответствует не только личным предпочтениям, но и ожиданиям людей,
которые будут поддерживать и развивать данный код. Слепое следование гайдлайнам может привести к тому, что код станет
соответствовать какому-то "канону", но если команда привыкла видеть другой стиль, то эффект будет обратным.
Универсальных решений не существует. Читаемость — это тонкий баланс между общепринятыми практиками и конкретными
особенностями проекта и команды.

#### 2. Простота

Простота кода оценивается его лаконичностью и понятностью. Нередко люди путают внешний вид кода с его внутренней
сложностью. Рассмотрим два примера:

```js
const user = db.collection('users').find({
    id: new UUID('507f1f77bcf86cd799439011')
});
```

```js
const user = getUsersService().getUserById('507f1f77bcf86cd799439011');
```

**Что может скрываться за «простой» обёрткой?**

1. **Скрытая логика и инфраструктура.**  
   Функция `getUserById` может выглядеть как простая обёртка, но внутри могут происходить сложнейшие процессы:
    - **Дедупликация запросов.** Если поступает несколько запросов к данным одновременно, сервис может группировать их,
      чтобы избежать лишних обращений к базе данных.
    - **Кэширование.** Перед обращением к базе данных функция может проверять, не сохранили ли уже нужного пользователя
      в быстром кэше, что значительно повышает производительность.
    - **Проверка прав и логика авторизации.** Обёртка может автоматически проверять, имеет ли пользователь право на
      просмотр запрошенных данных.
    - **Формирование запроса и валидация входных данных.** В этом процессе могут использоваться билдеры и валидаторы,
      которые гарантируют корректность запроса, и их код может быть довольно объёмным.

2. **Простота — это миф.**  
   Код в первом случае напрямую обращается к коллекции `users` базы данных. На первый взгляд он кажется
   «низкоуровневым», простым и прозрачным, но он требует от разработчика понимания деталей работы с базой, правильного
   формата данных (например, как именно должен передаваться `UUID`) и ручного контроля за всеми аспектами запроса.

3. **Сервисы и абстракции не делают код магически простым.**  
   Использование сервисного слоя (как во втором примере) позволяет спрятать всю сложную логику за понятным и лаконичным
   интерфейсом. Однако это не означает, что сама логика стала проще — она просто инкапсулирована в другом месте и может
   выполнять массу скрытых операций, которые критичны для корректной работы приложения.

4. **Сравнение и вывод.**
    - **Простота синтаксиса не гарантирует простоту логики.**  
      Обёртка `getUserById` выглядит намного легче для чтения, чем непосредственный вызов к базе, но именно за этой
      «красивой обёрткой» может скрываться куча механизмов, направленных на повышение производительности, безопасности,
      удобства тестирования и поддержки кода.
    - **Единственное, что выглядит простым — это поверхность, а не глубина.**  
      Аналогия с мифическими существами: единороги существуют только в ваших влажных снах. То, что разработчик видит на
      поверхности, не всегда отображает всю сложность процессов, лежащих в основе работы приложения.
    - **Единороги?**
      Если вы всё ещё застряли на единорогах, советую закрыть статейку на три минутки или сколько вам нужно, и очистить
      ваш грязный разум от отвлекающих факторов.

В конце концов, вы должны понимать, что простой код - это миф. Существует лишь ещё один уровень абстракции. И, как
говориться, любую проблему можно решить с использованием абстракции, кроме проблемы абстракции.

#### 3. Поддерживаемость

Поддерживаемость кода — это, по сути, сколько времени и нервов потребуется, чтобы внести в него изменения, адаптировать
его под новые требования, устранить баги или добавить новую функциональность. Но давайте разберём, почему идея
«поддерживаемости» зачастую оказывается мифом. Мифом, который придумали старые потные си плюс плюсники у себя в гаражах,
чекрыжа на идею о лёгком изменении кода в будущем, когда требования могут повернуться на 180 градусов и дать по яйцам
этим кретинам.

##### Почему поддерживаемость — легенда

1. **Постоянные изменения и дедлайны**  
   В мире, где AGILE-процессы, митинги и срочные запросы клиентов диктуют свои правила, разработчики могут буквально
   целыми днями «жонглировать» новыми фичами, почти не успевая позаботиться о том, чтобы код был идеальным с точки
   зрения архитектуры и чистоты.
    - Код меняется так быстро, что идеальный дизайн, задуманный изначально, становится чуждым уже через
      пару спринтов.

2. **Старая архитектура против новых требований**  
   То, что считалось удобным решением вчера, сегодня может оказаться полностью несовместимым с новыми
   бизнес-требованиями.
    - Старые архитектурные решения начинают «дуться», когда к ним подбирают новые функции, а
      инвестировать в рефакторинг — часто тяжелый удар по графику.

3. **Ухудшение качества с течением времени**  
   Быстрые изменения, минуя надлежащие проверки, приводят к тому, что изначально чистый код со временем превращается в
   настоящий ад для разработчиков, где исправление одной ошибки тянет за собой цепочку непредвиденных последствий.
    - «Поддерживаемость» оказывается словом утешения, к которому часто прибегают, когда система уже за
      годы эксплуатации обросла кучей недоделок, костылей и «глефов» (кодов, которые никто не хочет трогать).

4. **Финансовые потери и юридические риски**  
   Неухоженный код может стать источником уязвимостей, приводящих к утечкам данных, снижению производительности и даже
   судебным искам, если что-то идёт не так.
    - Пренебрежение качеством ради быстрого релиза может обернуться катастрофой для бизнеса.

##### Фактически, что важно на практике

Практика показывает, что, вместо того чтобы стремиться к химерной «поддерживаемости», важно иметь настоящих
профессионалов, способных разобраться в конском навозе, именуемым кодом, и, что ещё важнее, умение говорить
«нет» – когда некоторая фича или изменение прямо-таки грозит разрушить всё, над чем вы работали овертайм на протяжении
последних десяти эпиков. Слава SCRUM'у и его создателю (нет)!

- **Навыки программистов:**  
  Лучший актив — это лицо за разработкой, которое способно быстро понять, в каком состоянии находится код и как
  рационально подойти к его улучшению или изменению. Опытный разработчик понимает, что за «чистым» кодом может крыться
  куча адаптаций, компромиссов и хитростей, и умеет с этим работать. Гораздо практичнее этой вашей поддерживаемости.

- **Роль бизнес-аналитиков и менеджеров:**  
  Они часто требуют изменений, исходя из краткосрочных потребностей бизнеса, не учитывая глубину и взаимосвязь различных
  частей системы. Здесь критически важно, чтобы разработчики умели отстаивать технические рамки, аргументированно
  обосновывая, почему не стоит менять всё «на лету». Хотя иногда сохранить жопу от увольнения приоритетнее.

Поддерживаемость кода — это не волшебная кнопка, которая делает весь процесс разработки легким и безболезненным. Это
постоянный баланс между бизнес-требованиями, временем, ресурсами и техническими долгами. Код, как и любая сложная
система, требует постоянного внимания: рефакторинг, тестирование, оптимизация и четкое понимание того, что иногда нужно
просто сказать «нет», чтобы не пролить новый слой клея на и без того запутанную систему.

Так что, если вы всё ещё верите в мифическую поддерживаемость, помните: настоящая сила разработки — это способность
разбираться в сложностях, видеть за красивой обёрткой целый лабиринт процессов и, когда нужно, не побояться
противостоять давке бизнес-требований. Это и есть настоящая компетенция в мире программирования.

#### 4. Эффективность

Эффективность и скорость работы кода — важные вещи, но зачастую перестараться с оптимизациями — это путь в никуда,
особенно когда речь идёт об интерпретируемых языках. Давайте пройдёмся по пунктам.

##### Микро-оптимизации

Если вы пишете на JavaScript или, не дай бог, Python, то пытаться сэкономить несколько микросекунд на отдельном куске
кода — это маразм. Данные языки уже имеют накладные расходы по своей природе, гораздо более влиятельные, чем ваши
попытки заменить for на list comprehension. Не стоит забывать, что большая часть времени обработки веб запроса уходит на
выполнение запросов в БД.

Даже когда вы используете компилируемые и быстрые языки, такие как Go, Rust или Zig, попытки ускорить "горячие точки"
могут привести к тому, что вы либо не добьётесь нужного прироста, либо, наоборот, усложните код до неузнаваемости,
добавив какую-то непонятную "эзотерику", которая в итоге замедлит всю систему и дальнейшую разработку.

##### Меньше кода - меньше времени

Если цель — чтобы код работал быстрее, просто пишите меньше кода! Каждая лишняя строка, особенно если она добавляет свои
абстракции или накладные расходы, может негативно сказаться на производительности.
Для более ресурсосберегающего решения стоит выбирать низкоуровневые языки, где вы напрямую управляете ресурсами и можете
добиваться максимальной оптимизации под конкретное железо.

Не важно, какую ультракрутой алгоритм вы использовали в своём проекте, он никогда не будет быстрее, чем его отсутствие.
Если вы можете что-то убрать и получить тот же результат - вы нашли оптимальное решение эффективности.

##### Семь раз отмерь, один раз пошли погулять

Говорить, что один подход быстрее другого, не проведя до/после измерений, абсолютно бессмысленно. Оптимизация должна
начинаться с профилирования: замеряйте, где именно тратятся ресурсы, и только потом принимайте решение, что и как
менять.
Все должно измеряться в контексте реальных условий: конкретное оборудование, реальный датасет, определённые
бизнес-требования. Без этого любые утверждения об оптимальности остаются спекулятивными.

##### Проверка реальности

Писать два миллиона строк кода на Python и ожидать, что приложение будет работать как "идеальная лошадка" — это бред.

Оптимизация всегда имеет смысл там, где она действительно нужна. Если система работает достаточно быстро и её пропускная
способность соответствует ожиданиям, то перестараться с оптимизациями — это одна только трата усилий. Ведь время,
затраченное на "оптимизации", можно было бы потратить на разработку новых фич или на повышение качества кода в других
областях.

#### 5. Безопасность

Вам нужно что-то объяснять? Серьёзно? Сходите, почитайте **OWASP** [^7] что-ли...

Безопасность не должна быть показателем хорошего кода. Она просто должна быть. Точка. Если вы считаете, что можно иметь
на 90% безопасный код и наслаждаться этим - прошу проследовать в эту камеру. Пахнет чем-то странным? Не переживайте, мы
ещё ни разу не получали негативных отзывов.

#### 6. Документация

Документация, безусловно, важна, но она никак не компенсирует отсутствие хорошего кода. Можно задокументировать каждый
нюанс. Но пусть новый разработчик читает самую подробную документацию, если при открытии первого файла он увидит енотов,
роющихся в мусорном баке, то никакими комментариями или инструкциями эту проблему не исправишь.

> Идеальная, но устаревшая документация – ещё больший кошмар, чем её отсутствие.

##### Основные моменты:

1. **Код имеет первостепенное значение.**  
   Документация – это своего рода навигационная карта. Но если сама местность (код) напоминает развалины, то даже самая
   подробная карта не поможет понять, как добраться до пункта назначения.
    - Если код структурирован, читаем и логично разбит на модули, документация станет лишь приятным дополнением.
    - Если же сам код представляет собой разрозненный набор костылей и хаоса, документация способна лишь подчеркнуть
      этот контраст.

2. **Актуальность документации.**  
   Документировать нужно всё, но если документация не обновляется вместе с изменениями в коде, она утратит свою
   ценность.
    - Постоянно актуализировать документацию – задача не менее важная, чем поддержка самого кода.
    - Идеальная документация – это не статичный артефакт, а живая сущность, которая развивается вместе с продуктом.

3. **Код – лицо проекта.**  
   Когда новый разработчик начинает знакомство с проектом, он первым делом смотрит на код.
   Если он встречает там странь, то и доверие к проекту будет курить в сторонке, даже если к каждому методу или функции
   прилагается детальное описание.
    - Хороший код должен «рассказывать» сам за себя.
    - Документация должна быть вспомогательным инструментом, а не способом прикрыть недостатки архитектуры или
      реализации.

##### Итог:

Документация — это важный компонент, который помогает понять, как работает система, но сама по себе, она не делает код
хорошим. Идеальные комментарии и подробные описания не способны замаскировать хаос в исходном коде.

В конечном итоге, если уследить за тем, чтобы документация соответствовала состоянию программы, и чтобы код был понятным
и логичным, то вы создаёте действительно качественный продукт. Но если ваш код выглядит, как кипа неорганизованного
текста и костылей, то никакими подробными комментариями горькая правда не изменится.

#### 7. Стандарты

Стандарты действительно играют важную роль — они помогают минимизировать разногласия внутри команды, обеспечивают
определённый базовый уровень единообразия и облегчают интеграцию различных компонентов. Однако стандарты сами по себе
далеки от совершенства:

1. **Стандарты никогда не бывают идеальными.**  
   Посмотрите, сколько протоколов обмена данными, разъёмов для кабелей, а также различных библиотек для JavaScript
   существует сегодня. Каждый стандарт, будь то устоявшаяся практика или современная тенденция, имеет свои ограничения и
   не может удовлетворить абсолютно все потребности разных команд и проектов.

2. **Принудительное следование стандартам.**  
   Следуя какому-либо стандарту, вы можете значительно сократить количество споров, даже если все не любят его
   безоговорочно. Но при этом вы лишаете себя возможности выразить творческий подход или внедрить что-то новое, если
   стандарт не учитывает ваши реалии.

3. **Подход с пониманием компромиссов.**  
   Идеальным будет не слепое следование стандарту, а осознанный выбор: используйте его для снижения конфликтных
   ситуаций, но не забывайте, что иногда можно и нужно предложить улучшения. Никто не говорит, что нужно быть
   догматичным или отвергать все новое. Главное — сохранять баланс между компромиссами, необходимыми для командной
   работы, и критическим мышлением, позволяющим улучшать процессы.

4. **Настрой на конструктивное изменение.**  
   В действительности, соблюдение стандартов — это не конечная цель, а способ упростить взаимодействие. Если стандарт не
   удовлетворяет вашим потребностям, стоит подумать, как его можно адаптировать. Да, это может означать дополнительные
   разногласия, но именно через конструктивные споры и эксперименты рождаются инновационные подходы.

Следуйте стандартам, если они помогают вашей команде работать вместе, но не ожидайте, что они автоматически сделают ваш
код совершенным. Стандарты — лишь инструмент для упрощения коммуникации и поддержания единого стиля. Они не могут
заменить здравого смысла, профессионализма и желания постоянно улучшать свои решения. Помните: когда стандарт начинает
мешать развитию, возможно, самое время дать «пинка» тем, кто его установил — даже если вы сами были инициатором этого
стандарта.

## Не пост, не скриптум

Статья написана при поддержке нейронной сети ChatGPT o3-mini.

[^1]: [Clean Code](https://www.google.ru/books/edition/Clean_Code/_i6bDeoCQzsC)  
[^2]: [Принципы SOLID](https://en.wikipedia.org/wiki/SOLID)  
[^3]: [Refactoring](https://www.google.ru/books/edition/Refactoring/HmrDHwgkbPsC)  
[^4]: [Don't Repeat Yourself](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself)  
[^5]: [KISS-principle](https://en.wikipedia.org/wiki/KISS_principle)  
[^6]: [Effective Go](https://go.dev/doc/effective_go)
[^7]: [OWASP](https://owasp.org/www-project-top-ten/)